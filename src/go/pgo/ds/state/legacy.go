package state

// Implements centralized global state management API.
//
// Currently, PGo manages global state in a distributed environment by using the
// `etcd' key-value store. The functions defined here wrap that behaviour by providing
// a get/set interface so that if ever the way that we store global variables change,
// our API (and the code generated by the compiler) may hopefully stay the same.
//
// Usage:
//
// 	import (
// 		"fmt"
// 		"pgonet"
// 	)
//
// 	config := &GlobalsConfig{
// 		Endpoints: []string{"10.0.0.1:1234", "10.0.0.2:1234"},
// 		Timeout: 3,
// 	}
// 	state, err := pgonet.InitGlobals(config)
// 	if err != nil {
// 		// handle error
// 	}
//
// 	state.Set("project", "PGo")
// 	val := state.GetString("project")
// 	fmt.Printf("project value has value: %s\n", val) // project has value: PGo
//
// 	// Integers are also supported
// 	state.Set("count", 42)
// 	count := state.Get("count")
// 	fmt.Printf("count has value: %d\n", count) // count has value: 42
//
// 	// so are collections
// 	col := []string{"1", "2", "3"}
// 	state.Set("collection", col)
// 	col = state.GetStringCollection("collection")

// Implementation Details
//
// Global variables are stored in `etcd' as name => JSON object pairs. The JSON object
// that represents a variable contains information about the variable's current value,
// as well as its type (only ints and strings are currently supported).
//
// This representation is internal and applications need not know about it.

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	etcd "github.com/coreos/etcd/client"
)

type GlobalVariableType int

// declares the types of global variables supported by PGoNet at the moment.
const (
	TYPE_INT = iota
	TYPE_STRING
	PGONET_LOCK_NAMESPACE = "/locks/"
)

// Specifies how to connect to our global state management
type GlobalsConfig struct {
	Endpoints []string // a list of etcd endpoints in the IP:PORT format
	Timeout   int      // the timeout for each operation
}

// A reference to our global state, created via +InitGlobals+. Used in the
// generated Go code to set and get the values of global variables.
type GlobalState struct {
	c  etcd.Client
	kv etcd.KeysAPI
}

// a global variable, as stored in the key-value store
type globalVariable struct {
	Value        interface{}        `json:"value"`
	Type         GlobalVariableType `json:"type"`
	IsCollection bool               `json:"is_collection"`
}

// Initializes centralized global state management.
//
// The only currently supported global state management is the `centralized'
// strategy - that is, every request to global state is sent to the same server
// (or collection of servers).
//
// Returns a reference to `pgonet.GlobalState' on success. Fails if we cannot
// establish a connection to the etcd cluster.
func InitGlobals(cfg *GlobalsConfig) (*GlobalState, error) {
	etcdConfig := etcd.Config{
		Endpoints:               cfg.Endpoints,
		HeaderTimeoutPerRequest: time.Duration(cfg.Timeout) * time.Second,
	}

	c, err := etcd.New(etcdConfig)
	if err != nil {
		return nil, err
	}

	return &GlobalState{
		c:  c,
		kv: etcd.NewKeysAPI(c),
	}, nil
}

// Sets variable `name' to a given `value'. Contacts the global variable server
// *synchronously*
func (self *GlobalState) Set(name string, value interface{}) {
	switch val := value.(type) {
	case int:
		self.setInt(name, val)
	case string:
		self.setString(name, val)
	case []int:
		self.setIntCol(name, val)
	case []string:
		self.setStringCol(name, val)
	default:
		panic(fmt.Sprintf("Unsupported global variable type: %T\n", value))
	}
}

// indicates whether a variable with the given name was previously set.
// Caller must hold a lock before invoking this function if behavior following
// its return lies within a critical section
func (self *GlobalState) Exists(name string) bool {
	_, err := self.kv.Get(context.Background(), prepareKey(name), nil)
	if err != nil {
		etcdErr := err.(etcd.Error)
		if etcdErr.Code == etcd.ErrorCodeKeyNotFound {
			return false
		}

		panic(err)
	}

	return true
}

// Gets the value associated with a variable with the given `name'. The variable value
// is cast to an int and returned (the method fails if the value exists and is not a
// valid int). Contacts the global variable server *synchronously*
func (self *GlobalState) GetInt(name string) int {
	response, err := self.kv.Get(context.Background(), prepareKey(name), nil)
	if err != nil {
		panic(err)
	}

	gvar := parseGlobalVariable(response.Node.Value)
	if gvar.Type != TYPE_INT {
		panic(fmt.Sprintf("Variable %s: not an int", name))
	}

	return int(gvar.Value.(float64))
}

// Returns a string representation of the value associated with the variable with the
// given `name'.
func (self *GlobalState) GetString(name string) string {
	response, err := self.kv.Get(context.Background(), prepareKey(name), nil)
	if err != nil {
		panic(err)
	}

	gvar := parseGlobalVariable(response.Node.Value)
	if gvar.Type != TYPE_STRING {
		panic(fmt.Sprintf("Variable %s: not a string", name))
	}

	return gvar.Value.(string)
}

// Returns a collection of ints associated with the var of given `name'. The variable should
// be previously set to a []int using pgonet.Set.
func (self *GlobalState) GetIntCollection(name string) []int {
	response, err := self.kv.Get(context.Background(), prepareKey(name), nil)
	if err != nil {
		panic(err)
	}

	gvar := parseGlobalVariable(response.Node.Value)

	if !gvar.IsCollection {
		panic(fmt.Sprintf("Variable %s is not a collection", name))
	}

	icol := []int{}
	for _, el := range gvar.Value.([]interface{}) {
		// Go serializes "int-looking" values to float64. We need to convert to that type
		// first and then cast it to an int. Floats are currently not supported
		floatVal, ok := el.(float64)
		if !ok {
			panic(fmt.Sprintf("Variable %s is not a collection of ints", name))
		}

		icol = append(icol, int(floatVal))
	}

	return icol
}

// Returns a collection of strings associated with the var of given `name'. The variable should
// be previously set to a []string using pgonet.Set.
func (self *GlobalState) GetStringCollection(name string) []string {
	response, err := self.kv.Get(context.Background(), prepareKey(name), nil)
	if err != nil {
		panic(err)
	}

	gvar := parseGlobalVariable(response.Node.Value)

	if !gvar.IsCollection {
		panic(fmt.Sprintf("Variable %s is not a collection", name))
	}

	strCol := []string{}
	for _, el := range gvar.Value.([]interface{}) {
		strVal, ok := el.(string)
		if !ok {
			panic(fmt.Sprintf("Variable %s: not a collection of strings", name))
		}

		strCol = append(strCol, strVal)
	}

	return strCol
}

func (self *GlobalState) setInt(name string, value int) {
	variable := globalVariable{
		Value:        value,
		Type:         TYPE_INT,
		IsCollection: false,
	}

	_, err := self.kv.Set(context.Background(), prepareKey(name), serialize(variable), nil)
	if err != nil {
		panic(err)
	}
}

func (self *GlobalState) setString(name, value string) {
	variable := globalVariable{
		Value:        value,
		Type:         TYPE_STRING,
		IsCollection: false,
	}

	_, err := self.kv.Set(context.Background(), prepareKey(name), serialize(variable), nil)
	if err != nil {
		panic(err)
	}
}

func (self *GlobalState) setIntCol(name string, val []int) {
	variable := globalVariable{
		Value:        val,
		Type:         TYPE_INT,
		IsCollection: true,
	}

	_, err := self.kv.Set(context.Background(), prepareKey(name), serialize(variable), nil)
	if err != nil {
		panic(err)
	}
}

func (self *GlobalState) setStringCol(name string, val []string) {
	variable := globalVariable{
		Value:        val,
		Type:         TYPE_STRING,
		IsCollection: true,
	}

	_, err := self.kv.Set(context.Background(), prepareKey(name), serialize(variable), nil)
	if err != nil {
		panic(err)
	}
}

func (self *GlobalState) Lock(who, which string) error {
	key := prepareLock(which)
	for {
		_, err := self.kv.Create(context.Background(), key, who)
		etcdErr, ok := err.(etcd.Error)
		if !ok {
			return err
		}
		if etcdErr.Code != etcd.ErrorCodeNodeExist {
			return err
		}
	}
}

func (self *GlobalState) Unlock(who, which string) error {
	_, err := self.kv.Delete(context.Background(), prepareLock(which), &etcd.DeleteOptions{
		PrevValue: who,
	})
	return err
}

// given a key k, this method transforms it to the format expected by `etcd'
func prepareKey(k string) string {
	return "/" + k
}

// given a lock k, this method transforms it to the format expected by `etcd'
func prepareLock(k string) string {
	return PGONET_LOCK_NAMESPACE + k
}

func serialize(v globalVariable) string {
	b, _ := json.Marshal(v)
	return string(b)
}

func parseGlobalVariable(s string) globalVariable {
	var v globalVariable
	json.Unmarshal([]byte(s), &v)

	return v
}
