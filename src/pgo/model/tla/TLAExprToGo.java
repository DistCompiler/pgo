package pgo.model.tla;

import pgo.model.golang.*;
import pgo.model.intermediate.PGoFunction;
import pgo.model.intermediate.PGoLibFunction;
import pgo.model.intermediate.PGoVariable;
import pgo.model.type.*;
import pgo.trans.PGoTransException;
import pgo.trans.PGoTransExpectedASetException;
import pgo.trans.PGoTransExpectedSingleExpressionException;
import pgo.trans.intermediate.PGoTempData;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

/**
 * Converts the TLA ast generated by the TLAExprParser into GoAST
 *
 */
public class TLAExprToGo {
	// the resulting GoAST expression
	private Expression expr;
	// the inferred type of the expression
	private PGoType type;
	// the Go program's imports
	private Imports imports;
	// the intermediate data; includes information about the type of variables
	private PGoTempData data;

	public TLAExprToGo(PGoTLAExpression tla, Imports imports, PGoTempData data) throws PGoTransException {
		this.imports = imports;
		this.data = data;
		type = new TLAExprToType(tla, data).getType().substitute(data.solver.getMapping()).realize();
		tla.setType(type);
		expr = tla.convert(this);
	}

	public PGoType getType() {
		return type;
	}

	public Expression toExpression() {
		return expr;
	}

	/**
	 * Convert the TLA expression to a Go AST, while also adding the correct
	 * imports.
	 * 
	 * @param tla
	 *            the TLA expression
	 */
	protected Expression translate(PGoTLAArray tla) throws PGoTransException {
		if (tla.getContents().size() == 1 && tla.getContents().get(0) instanceof PGoTLAVariadic) {
			// maps to or except operator
			return new TLAExprToGo(tla.getContents().get(0), imports, data).toExpression();
		}
		// array, tuple or chan, depending on assigned type
		Vector<Expression> contents = new Vector<>();
		// make sure we maintain the assign type
		if (type instanceof PGoTypeTuple) {
			for (int i = 0; i < tla.getContents().size(); i++) {
				Expression e = new TLAExprToGo(tla.getContents().get(i), imports, data).toExpression();
				contents.add(e);
			}
		} else {
			for (PGoTLAExpression elt : tla.getContents()) {
				Expression e = new TLAExprToGo(elt, imports, data).toExpression();
				contents.add(e);
			}
		}
		if (type instanceof PGoTypeTuple) {
			return new FunctionCall("datatypes.NewTuple", contents);
		} else if (type instanceof PGoTypeSlice) {
			// << 1, 2, 3 >> -> []int{1, 2, 3}
			Vector<Expression> se = new Vector<>();
			se.add(new Token(type.toGo()));
			se.add(new Token("{"));
			for (int i = 0; i < contents.size(); i++) {
				if (i > 0) {
					se.add(new Token(","));
				}
				se.add(contents.get(i));
			}
			se.add(new Token("}"));
			return new SimpleExpression(se);
		} else if (type instanceof PGoTypeChan) {
			return new FunctionCall("datatypes.NewChan", contents);
		}
		throw new PGoTransException("Invalid collection type " + type.toTypeName(), tla.getLine());
	}

	protected Expression translate(PGoTLAVariadic tla) throws PGoTransException {
		// TODO
		switch (tla.getToken()) {
		case "|->":
			// tla: x \in S, y \in T |-> f(x, y)
			// go: datatypes.MapsTo(func(x, y type) type { return f(x, y) }, S, T)
			// func params to MapsTo
			Vector<Expression> params = new Vector<>();
			// params for anonymous function
			Vector<ParameterDeclaration> decls = new Vector<>();
			PGoTempData temp = new PGoTempData(data);
			for (PGoTLAExpression arg : tla.getArgs()) {
				assert (arg instanceof PGoTLASetOp);
				PGoTLASetOp in = (PGoTLASetOp) arg;
				assert (in.getToken().equals("\\in"));
				// TODO handle tuples
				assert (in.getLeft() instanceof PGoTLAVariable);
				PGoTLAVariable var = (PGoTLAVariable) in.getLeft();
				PGoType setType = new TLAExprToType(in.getRight(), data).getType();
				if (!(setType instanceof PGoTypeSet)) {
					throw new PGoTransException("Expected a set", tla.getLine());
				}
				PGoType containedType = ((PGoTypeSet) setType).getElementType();

				decls.add(new ParameterDeclaration(var.getName(), containedType));
				params.add(new TLAExprToGo(in.getRight(), imports, data).toExpression());

				temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), containedType));
			}
			// Create anonymous function for f
			TLAExprToGo trans = new TLAExprToGo(tla.getExpr(), imports, temp);
			AnonymousFunction f = new AnonymousFunction(trans.getType(), decls, new Vector<>(),
					Collections.singletonList(new Return(trans.toExpression())));
			params.add(0, f);
			imports.addImport("pgo/datatypes");
			return new FunctionCall("datatypes.MapsTo", params);
		case "EXCEPT":
			// tla: f EXCEPT ![x1] = y1, [x2] = y2...
			// TODO
			return null;
		case ":":
			// if we are calling this, it is set constructor or set image
			if (tla.isRightSide()) {
				// set image { f(x, y) : x \in S, y \in T }
				// go func: datatypes.SetImage(func(x, y type) type { return f(x,
				// y) }, S, T)

				// the set operations
				Vector<Expression> varExprs = new Vector<>(), setExprs = new Vector<>();
				// add temporary typing data used to translate the predicate
				temp = new PGoTempData(data);
				// parameters for anonymous function
				decls = new Vector<>();
				// the SetImage function parameters
				params = new Vector<>();
				for (PGoTLAExpression arg : tla.getArgs()) {
					PGoTLASetOp setOp = (PGoTLASetOp) arg;
					varExprs.add(new TLAExprToGo(setOp.getLeft(), imports, data).toExpression());
					setExprs.add(new TLAExprToGo(setOp.getRight(), imports, data).toExpression());
					// TODO handle tuples
					assert (setOp.getLeft() instanceof PGoTLAVariable);
					PGoTLAVariable var = (PGoTLAVariable) setOp.getLeft();
					PGoType setType = new TLAExprToType(setOp.getRight(), data).getType();
					if (!(setType instanceof PGoTypeSet)) {
						throw new PGoTransExpectedASetException(tla.getLine());
					}
					PGoType containedType = ((PGoTypeSet) setType).getElementType();

					decls.add(new ParameterDeclaration(var.getName(), containedType));
					params.add(new TLAExprToGo(setOp.getRight(), imports, data).toExpression());

					temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), containedType));
				}
				trans = new TLAExprToGo(tla.getExpr(), imports, temp);
				f = new AnonymousFunction(trans.getType(), decls, new Vector<>(),
						Collections.singletonList(new Return(trans.toExpression())));
				params.add(0, f);
				imports.addImport("pgo/datatypes");
				return new FunctionCall("datatypes.SetImage", params);
			} else {
				// set constructor { x \in S : P(x) }
				// go func: datatypes.SetConstructor(S, func(x type) bool { return
				// P(x) })
				// there is only a single set expression S

				assert (tla.getArgs().size() == 1);
				PGoTLASetOp setOp = (PGoTLASetOp) tla.getArgs().get(0);
				TLAExprToGo setTrans = new TLAExprToGo(setOp.getRight(), imports, data);
				if (!(setTrans.getType() instanceof PGoTypeSet)) {
					throw new PGoTransExpectedASetException(tla.getLine());
				}
				PGoType varType = ((PGoTypeSet) setTrans.getType()).getElementType();

				// TODO handle tuples
				assert (setOp.getLeft() instanceof PGoTLAVariable);
				PGoTLAVariable var = (PGoTLAVariable) setOp.getLeft();
				temp = new PGoTempData(data);
				temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), varType));

				AnonymousFunction P = new AnonymousFunction(
						PGoTypeBool.getInstance(),
						Collections.singletonList(new ParameterDeclaration(var.getName(), varType)),
						new Vector<>(),
						Collections.singletonList(new Return(new TLAExprToGo(tla.getExpr(), imports, temp).toExpression())));
				imports.addImport("pgo/datatypes");
				return new FunctionCall("datatypes.SetConstructor", Arrays.asList(setTrans.toExpression(), P));
			}
		default:
			throw new PGoTransException("Invalid PGoTLAVariadic operator", tla.getLine());
		}
	}

	protected Expression translate(PGoTLABool tla) {
		return new Token(String.valueOf(tla.getVal()));
	}

	protected Expression translate(PGoTLABoolOp tla) throws PGoTransException {
		TLAExprToGo left = new TLAExprToGo(tla.getLeft(), imports, data);
		TLAExprToGo right = new TLAExprToGo(tla.getRight(), imports, data);
		Expression leftRes = left.toExpression();
		Expression rightRes = right.toExpression();

		// we have already checked types for consistency, so can check just lhs
		PGoType leftType = left.getType();
		if (leftType instanceof PGoTypeSet) {
			imports.addImport("pgo/datatypes");
			Vector<Expression> leftExp = new Vector<>();
			leftExp.add(leftRes);

			switch (tla.getToken()) {
			case "#":
			case "/=":
				Vector<Expression> toks = new Vector<>();
				toks.add(new Token("!"));
				toks.add(new FunctionCall("Equal", leftExp, rightRes));
				return new SimpleExpression(toks);
			case "=":
			case "==":
				return new FunctionCall("Equal", leftExp, rightRes);
			default:
				throw new PGoTransException("Invalid bool op on set", tla.getLine());
			}
		}

		String tok = tla.getToken();
		switch (tok) {
		case "#":
		case "/=":
			tok = "!=";
			break;
		case "/\\":
		case "\\land":
			tok = "&&";
			break;
		case "\\/":
		case "\\lor":
			tok = "||";
			break;
		case "=<":
		case "\\leq":
			tok = "<=";
			break;
		case "\\geq":
			tok = ">=";
			break;
		case "=":
			tok = "==";
			break;
		}

		// if we are comparing number types we may need to do type conversion
		if (leftType instanceof PGoNumberType) {
			PGoType rightType = new TLAExprToType(tla.getRight(), data).getType();
			PGoType fresh = new PGoTypeUnrealizedNumber();
			data.solver.accept(new PGoTypeConstraint(fresh, rightType, tla.getLine()));
			data.solver.accept(new PGoTypeConstraint(fresh, leftType, tla.getLine()));
			data.solver.unify();
			data.solver.simplify();
			fresh = fresh.realize();
			// cast if not plain number
			if (!leftType.equals(fresh) && !(tla.getLeft() instanceof PGoTLANumber)) {
				leftRes = new TypeConversion(fresh, leftRes);
			} else if (!rightType.equals(fresh) && !(tla.getRight() instanceof PGoTLANumber)) {
				// only one of the left or right needs to be cast
				rightRes = new TypeConversion(fresh, rightRes);
			}
		}

		Vector<Expression> toks = new Vector<>();
		toks.add(leftRes);
		toks.add(new Token(" " + tok + " "));
		toks.add(rightRes);

		return new SimpleExpression(toks);
	}

	protected Expression translate(PGoTLAFunctionCall tla) throws PGoTransException {
		Vector<Expression> params = new Vector<>();
		for (PGoTLAExpression param : tla.getParams()) {
			params.add(new TLAExprToGo(param, imports, data).toExpression());
		}
		// Determine whether this is a PlusCal macro call, TLA definition call,
		// TLA builtin method call, or map/slice/tuple access.
		PGoFunction func = data.findPGoFunction(tla.getName());
		PGoTLADefinition def = data.findTLADefinition(tla.getName());
		PGoLibFunction lfunc = data.findBuiltInFunction(tla.getName());
		PGoVariable var = data.findPGoVariable(tla.getName());
		// TODO: change Head and Tail to a proper construct in the compiler
		// Head(e) is translated to e[0]
		if (tla.getName().equals("Head")) {
			Vector<Expression> exp = new Vector<>();
			exp.addAll(params);
			exp.add(new Token("[0]"));
			return new SimpleExpression(exp);
		} else if (tla.getName().equals("Tail")) {
			// Tail(e) is translated to e[1:]
			Vector<Expression> exp = new Vector<>();
			exp.addAll(params);
			exp.add(new Token("[1:]"));
			return new SimpleExpression(exp);
		} else if (func != null || def != null) {
			return new FunctionCall(tla.getName(), params);
		} else if (lfunc != null) {
			Vector<PGoType> paramTypes = new Vector<>();
			for (PGoTLAExpression param : tla.getParams()) {
				paramTypes.add(new TLAExprToType(param, data).getType());
			}
			PGoLibFunction.LibFuncInfo fInfo = lfunc.getFunc(data.typeGenerator, paramTypes).get();
			String goName = fInfo.getGoName();
			if (fInfo.isObjMethod()) {
				// the object is the 1st param
				Expression first = params.remove(0);
				return new FunctionCall(goName, params, first);
			} else {
				return new FunctionCall(goName, params);
			}
		} else {
			if (var.getType() instanceof PGoTypeTuple) {
				// also need to cast element to correct type
				if (!(params.size() == 1)) {
					throw new PGoTransExpectedSingleExpressionException(tla.getLine());
				}
				// PlusCal tuples are 1-indexed, so need to subtract 1
				Vector<Expression> se = new Vector<>();
				se.add(params.get(0));
				se.add(new Token(" - "));
				se.add(new Token("1"));
				params.set(0, new SimpleExpression(se));

				return new TypeAssertion(new FunctionCall("At", params, new Token(tla.getName())), type);
			} else if (var.getType() instanceof PGoTypeSlice) {
				Vector<Expression> se = new Vector<>();
				assert (params.size() == 1);

				// PlusCal tuples are 1-indexed, so need to subtract 1
				se.add(new Token(tla.getName()));
				se.add(new Token("["));
				se.add(params.get(0));
				se.add(new Token(" - "));
				se.add(new Token("1"));
				se.add(new Token("]"));
				return new SimpleExpression(se);
			} else {
				// map
				if (params.size() > 1) {
					// tuple key
					FunctionCall newTup = new FunctionCall("datatypes.NewTuple", params);
					return new TypeAssertion(new FunctionCall("Get",
							Collections.singletonList(newTup),
							new Token(tla.getName())),
							type);
				} else {
					return new TypeAssertion(new FunctionCall("Get", params, new Token(tla.getName())), type);
				}
			}
		}
	}

	protected Expression translate(PGoTLAGroup tla) throws PGoTransException {
		Expression inside = new TLAExprToGo(tla.getInner(), imports, data).toExpression();
		return new Group(inside);
	}

	protected Expression translate(PGoTLANumber tla) {
		return new Token(tla.getVal());
	}

	protected Expression translate(PGoTLASequence tla) throws PGoTransException {
		TLAExprToGo start = new TLAExprToGo(tla.getStart(), imports, data);
		TLAExprToGo end = new TLAExprToGo(tla.getEnd(), imports, data);
		Expression startRes = start.toExpression();
		Expression endRes = end.toExpression();

		Vector<Expression> args = new Vector<>();
		// we may need to convert natural to int
		PGoType startType = start.getType();
		PGoType endType = end.getType();
		// plain numbers are never naturals (int or float only), so we don't
		// need to check if the exprs are plain numbers
		if (startType instanceof PGoTypeNatural) {
			startRes = new TypeConversion(PGoTypeInt.getInstance(), startRes);
		}
		if (endType instanceof PGoTypeNatural) {
			endRes = new TypeConversion(PGoTypeInt.getInstance(), endRes);
		}
		args.add(startRes);
		args.add(endRes);

		this.imports.addImport("pgo/datatypes");
		return new FunctionCall("datatypes.Sequence", args);
	}

	protected Expression translate(PGoTLASet tla) throws PGoTransException {
		if (tla.getContents().size() == 1 && tla.getContents().get(0) instanceof PGoTLAVariadic) {
			// this is set constructor/set image: handled with that translation
			// method
			return new TLAExprToGo(tla.getContents().get(0), imports, data).toExpression();
		}
		PGoType containedType = ((PGoTypeSet) type).getElementType();
		Vector<Expression> args = new Vector<>();
		for (PGoTLAExpression ptla : tla.getContents()) {
			args.add(new TLAExprToGo(ptla, imports, data).toExpression());
		}
		this.imports.addImport("pgo/datatypes");
		return new FunctionCall("datatypes.NewSet", args);
	}

	protected Expression translate(PGoTLASetOp tla) throws PGoTransException {
		Expression leftRes = new TLAExprToGo(tla.getLeft(), imports, data).toExpression();
		Expression rightRes = new TLAExprToGo(tla.getRight(), imports, data).toExpression();

		Vector<Expression> lhs = new Vector<>();
		lhs.add(leftRes);

		Vector<Expression> exp = new Vector<>();
		String funcName = null;
		// Map the set operation to the pgo/datatypes set function. \\notin does not
		// have a corresponding function and is handled separately.
		switch (tla.getToken()) {
		case "\\cup":
		case "\\union":
			funcName = "Union";
			break;
		case "\\cap":
		case "\\intersect":
			funcName = "Intersect";
			break;
		case "\\in":
			funcName = "Contains";
			break;
		case "\\notin":
			funcName = "NotIn";
			break;
		case "\\subseteq":
			funcName = "IsSubset";
			break;
		case "\\":
			funcName = "Difference";
			break;
		default:
			assert false;
		}

		if (funcName.equals("NotIn")) {
			exp.add(new Token("!"));
			funcName = "Contains";
		}
		// rightRes is the object because lhs can be an element (e.g. in
		// Contains) except when calling Difference (not symmetric)
		this.imports.addImport("pgo/datatypes");
		if (tla.getToken().equals("\\")) {
			exp.add(new FunctionCall(funcName, Collections.singletonList(rightRes), leftRes));
		} else {
			exp.add(new FunctionCall(funcName, lhs, rightRes));
		}
		return new SimpleExpression(exp);
	}

	protected Expression translate(PGoTLASimpleArithmetic tla) throws PGoTransException {
		TLAExprToGo left = new TLAExprToGo(tla.getLeft(), imports, data);
		TLAExprToGo right = new TLAExprToGo(tla.getRight(), imports, data);
		Expression leftRes = left.toExpression();
		Expression rightRes = right.toExpression();
		PGoType leftType = left.getType();
		PGoType rightType = right.getType();

		if (tla.getToken().equals("^")) {
			this.imports.addImport("math");
			Vector<Expression> params = new Vector<>();
			// math.Pow takes float64s; convert if needed
			if (!(tla.getLeft() instanceof PGoTLANumber || leftType instanceof PGoTypeDecimal)) {
				leftRes = new TypeConversion(PGoTypeDecimal.getInstance(), leftRes);
			}
			if (!(tla.getRight() instanceof PGoTLANumber || rightType instanceof PGoTypeDecimal)) {
				rightRes = new TypeConversion(PGoTypeDecimal.getInstance(), rightRes);
			}
			params.add(leftRes);
			params.add(rightRes);
			return new FunctionCall("math.Pow", params);
		} else {
			if (!(tla.getLeft() instanceof PGoTLANumber) && !leftType.equals(type)) {
				leftRes = new TypeConversion(type, leftRes);
			} else if (!(tla.getRight() instanceof PGoTLANumber) && !rightType.equals(type)) {
				rightRes = new TypeConversion(type, rightRes);
			}

			Vector<Expression> toks = new Vector<>();
			toks.add(leftRes);
			toks.add(new Token(" " + tla.getToken() + " "));
			toks.add(rightRes);
			return new SimpleExpression(toks);
		}
	}

	protected Expression translate(PGoTLAString tla) {
		return new Token("\"" + tla.getString() + "\"");
	}

	protected Expression translate(PGoTLAUnary tla) throws PGoTransException {
		switch (tla.getToken()) {
		case "~":
		case "\\lnot":
		case "\\neg":
			Expression expr = new TLAExprToGo(tla.getArg(), imports, data).toExpression();
			Vector<Expression> exp = new Vector<>();
			exp.add(new Token("!"));
			exp.add(expr);
			return new SimpleExpression(exp);
		case "UNION":
			expr = new TLAExprToGo(tla.getArg(), imports, data).toExpression();
			FunctionCall fc = new FunctionCall("EltUnion", new Vector<>(), expr);
			this.imports.addImport("pgo/datatypes");
			return fc;
		case "SUBSET":
			expr = new TLAExprToGo(tla.getArg(), imports, data).toExpression();
			FunctionCall fc1 = new FunctionCall("PowerSet", new Vector<>(), expr);
			this.imports.addImport("pgo/datatypes");
			return fc1;
		// these operations are of the form OP x \in S : P(x)
		case "CHOOSE":
			PGoTLAVariadic st = (PGoTLAVariadic) tla.getArg();
			assert (st.getArgs().size() == 1);
			// the set S
			Expression setExpr = new TLAExprToGo(((PGoTLASetOp) st.getArgs().get(0)).getRight(), imports, data)
					.toExpression();
			
			// We need to add typing data to avoid TLAExprToType complaining
			// about untyped variables
			PGoTempData temp = new PGoTempData(data);
			for (PGoTLAExpression arg : st.getArgs()) {
				PGoTLASetOp set = (PGoTLASetOp) arg;
				// TODO handle stuff like << x, y >> \in S \X T
				assert (set.getLeft() instanceof PGoTLAVariable);
				PGoTLAVariable var = (PGoTLAVariable) set.getLeft();
				PGoType containerType = new TLAExprToType(set.getRight(), data).getType();
				assert (containerType instanceof PGoTypeSet);
				PGoType eltType = ((PGoTypeSet) containerType).getElementType();
				temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), eltType));
			}
			Expression pred = new TLAExprToGo(st.getExpr(), imports, temp).toExpression();
			// most expressions can't be used as the variable (only stuff like
			// tuples) so this should be one line
			// the variable x
			Expression varExpr = new TLAExprToGo(((PGoTLASetOp) st.getArgs().get(0)).getLeft(), imports, temp)
								.toExpression();
			assert (varExpr.toGo().size() == 1);

			// create the anonymous function for the predicate
			// go func: Choose(P interface{}, S datatypes.Set) interface{}
			// (P is predicate)
			// P = func(varType) bool { return pred }
			AnonymousFunction P = new AnonymousFunction(PGoTypeBool.getInstance(),
					// TODO (issue 28) deal with tuples as variable declaration
					Collections.singletonList(new ParameterDeclaration(varExpr.toGo().get(0),
									new TLAExprToType(tla, data).getType())),
					new Vector<>(),
					Collections.singletonList(new Return(pred)));

			Vector<Expression> chooseFuncParams = new Vector<>();
			chooseFuncParams.add(P);
			chooseFuncParams.add(setExpr);

			this.imports.addImport("pgo/datatypes");
			return new FunctionCall("datatypes.Choose", chooseFuncParams);
		case "\\E":
		case "\\A":
			st = (PGoTLAVariadic) tla.getArg();

			temp = new PGoTempData(data);
			for (PGoTLAExpression arg : st.getArgs()) {
				PGoTLASetOp set = (PGoTLASetOp) arg;
				// TODO handle stuff like << x, y >> \in S \X T
				if (!(set.getLeft() instanceof PGoTLAVariable)) {
					throw new PGoTransException("Expected a variable", tla.getLine());
				}
				PGoTLAVariable var = (PGoTLAVariable) set.getLeft();
				PGoType containerType = new TLAExprToType(set.getRight(), data).getType();
				if (!(containerType instanceof PGoTypeSet)) {
					throw new PGoTransExpectedASetException(tla.getLine());
				}
				PGoType eltType = ((PGoTypeSet) containerType).getElementType();
				temp.getLocals().put(var.getName(), PGoVariable.convert(var.getName(), eltType));
			}
			pred = new TLAExprToGo(st.getExpr(), imports, temp).toExpression();

			Vector<Expression> setExprs = new Vector<>(), varExprs = new Vector<>();
			for (PGoTLAExpression arg : st.getArgs()) {
				PGoTLASetOp setOp = (PGoTLASetOp) arg;
				varExprs.add(new TLAExprToGo(setOp.getLeft(), imports, temp).toExpression());
				setExprs.add(new TLAExprToGo(setOp.getRight(), imports, data).toExpression());
			}
			// create the anonymous function for the predicate
			// go func: Exists|ForAll(P interface{}, S ...datatypes.Set)
			// interface{}
			// (P is predicate)
			// P = func(varType, varType...) bool { return pred }
			Vector<ParameterDeclaration> params = new Vector<>();
			for (int i = 0; i < setExprs.size(); i++) {
				PGoTLAExpression setExprTLA = ((PGoTLASetOp) st.getArgs().get(i)).getRight();
				PGoType setType = new TLAExprToType(setExprTLA, data).getType();
				PGoType varType = ((PGoSimpleContainerType) setType).getElementType();
				params.add(new ParameterDeclaration(varExprs.get(i).toGo().get(0), varType));
			}
			P = new AnonymousFunction(PGoTypeBool.getInstance(),
					// TODO (issue 28) deal with tuples as variable declaration
					params,
					new Vector<>(),
					Collections.singletonList(new Return(pred)));

			Vector<Expression> funcParams = new Vector<>();
			funcParams.add(P);
			funcParams.addAll(setExprs);

			this.imports.addImport("pgo/datatypes");
			return new FunctionCall((tla.getToken().equals("\\E") ? "datatypes.Exists" : "datatypes.ForAll"),
					funcParams);
		}
		throw new PGoTransException("Invalid unary operator", tla.getLine());
	}

	protected Expression translate(PGoTLAVariable tla) {
		return new Expression() {
			@Override
			public List<String> toGo() {
				PGoVariable var = data.findPGoVariable(tla.getName());
				return new VariableReference(var.getName(), var, data.cachedVarSet.contains(var), data.netOpts.getStateStrategy()).toGo();
			}
		};
	}
}
