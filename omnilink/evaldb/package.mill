package build.omnilink.evaldb

import mill.*

import scalasql.*, PostgresDialect.*
import mill.api.BuildCtx
import scala.util.Using
import java.time.LocalDateTime

trait EvalDBTrait:
  def dbPath: os.SubPath
  def createTablesSQL: os.SubPath

  final case class AutoCloseClient(client: DbClient, closeFn: () => Unit)
      extends AutoCloseable:
    export client.*
    def close(): Unit =
      closeFn()
  end AutoCloseClient

  private lazy val fn =
    Class.forName("org.duckdb.DuckDBDriver")
    val fn = () =>
      @scala.annotation.tailrec
      def retry(): AutoCloseClient =
        try
          val conn = java.sql.DriverManager.getConnection(
            s"jdbc:duckdb:${BuildCtx.workspaceRoot / dbPath}",
          )
          val client = DbClient.Connection(conn)
          AutoCloseClient(client, conn.close)
        catch
          case ex: java.sql.SQLException =>
            if ex.getMessage().contains("Could not set lock on file")
            then
              println(s"DuckDB file lock contention, backing off...")
              Thread.sleep(1000)
              retry()
            else throw ex
      end retry
      retry()
    end fn

    Using.resource(fn()): conn =>
      val db = conn.getAutoCommitClientConnection
      db.updateRaw(os.read(BuildCtx.workspaceRoot / createTablesSQL))

    fn
  end fn

  def dbClient: () => AutoCloseClient = fn
end EvalDBTrait

object EvalDB extends Module, EvalDBTrait:
  def createTablesSQL = os.sub / "omnilink" / "createTables.sql"
  def dbPath = os.sub / "omnilink" / "eval.duckdb"

  given workspacePathMapper: TypeMapper[os.Path] =
    TypeMapper[String].bimap(
      _.relativeTo(BuildCtx.workspaceRoot).toString,
      os.Path(_, BuildCtx.workspaceRoot),
    )

  case class Config[T[_]](
      id: T[String],
      expectedExperimentCount: T[Int],
  )
  object Config extends Table[Config]

  case class Experiment[T[_]](
      configId: T[String],
      idx: T[Int],
      github: T[String],
      branch: T[String],
      specPath: T[os.Path],
      mcSpecPath: T[os.Path],
      mcConfigPath: T[os.Path],
      startTime: T[LocalDateTime],
      endTime: T[LocalDateTime],
      exitCode: T[Int],
      rrZip: T[geny.Bytes],
  )
  object Experiment extends Table[Experiment]

  case class Trace[T[_]](
      configId: T[String],
      experimentIdx: T[Int],
      id: T[Int],
      trace: T[geny.Bytes],
  )
  object Trace extends Table[Trace]

  case class GatherLog[T[_]](
      configId: T[String],
      experimentIdx: T[Int],
      name: T[String],
      text: T[String],
  )
  object GatherLog extends Table[GatherLog]

  case class Validation[T[_]](
      configId: T[String],
      experimentIdx: T[Int],
      logTxt: T[String],
      startTime: T[LocalDateTime],
      endTime: T[LocalDateTime],
      success: T[Boolean],
      counterExampleBin: T[Option[geny.Bytes]],
  )
  object Validation extends Table[Validation]
end EvalDB
