package build.omnilink

import mill.*
import mill.util.Jvm
import mill.api.{BuildCtx, ModuleRef}
import mill.api.Evaluator

trait TraceEvalSpecModule extends Module:
  def spec: T[PathRef]
  def specHPP: T[PathRef] = Task:
    val destFile = Task.dest / "workload-meta.hpp"
    build.omnilink.tool
      .runner()
      .run(
        List[os.Shellable](
          "gen-hpp",
          spec().path,
          "--out-file",
          destFile,
        ),
      )
    PathRef(destFile)
  end specHPP
end TraceEvalSpecModule

def omnilinkLibHPP: T[PathRef] =
  Task.Source(os.sub / "omnilink-lib.hpp")

object wiredtiger extends TraceEvalSpecModule:
  def deriv: T[PathRef] = Task.Source(os.sub)

  def spec = Task.Source(os.sub / "Storage.tla")
  def mainCPP = Task.Source(os.sub / "main.cpp")

  object release_11_3_1 extends WTTracingConfigModule:
    def wtVersion = "v11_3_1"
    def specToValidate = spec()
    def specToValidateMC =
      Task.Source(wiredtiger.moduleDir / "MCStorageValidate.tla")
    def specToValidateMCConfig =
      Task.Source(wiredtiger.moduleDir / "MCStorageValidate.cfg")

    object defaultConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 100
    end defaultConfig
    object longConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 10000
    end longConfig
    object wideConfig extends ConfigModule:
      def threadCount = 50
      def operationCount = 100
    end wideConfig
  end release_11_3_1

  trait WTTracingConfigModule extends TracingConfigModule:
    def wtVersion: T[String]
    def tracingExecutable: T[PathRef] = Task:
      val includes = List(
        specHPP().path / os.up,
        omnilinkLibHPP().path / os.up,
      )
      val libs = List(
        "pthread",
        "rt",
        "dl",
        "wiredtiger",
      )
      val exeDest = Task.dest / "main"

      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          s"${deriv().path}#${wtVersion()}",
          "-c",
          "g++",
          "-g",
          "-O3",
          mainCPP().path, // put this up here or linker fails occur
          includes.map(p => s"-I$p"),
          libs.map(l => s"-l$l"),
          "-o",
          exeDest,
        ),
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(exeDest)
    end tracingExecutable
  end WTTracingConfigModule
end wiredtiger

object setbench extends TraceEvalSpecModule:
  object repo extends GitRepoModule:
    def origin = "git@github.com:ubc-systopia/augmented-chromatic-trees.git"
    object paper1 extends CommitHash:
      def commitHash = "cb4562bb8459b848685738fb1f00c2a015b56be2"
  end repo
  def spec = Task.Source(os.sub / "ChromaticTree.tla")
  def cmakeLists = Task.Source(os.sub / "CMakeLists.txt")
  // def mainCPP = Task.Source(os.sub / "main.cpp")

  def deriv: T[PathRef] = Task.Source(os.sub)

  object brown_ext_chromatic_augment_lf extends SetBenchTracingConfigModule:
    def dsSubFolder = os.sub / "ds" / "brown_ext_chromatic_augment_lf"
    def commitHashDir = repo.paper1.dir()

    object defaultConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 100
    end defaultConfig
    object longConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 100000
    end longConfig
    object wideConfig extends ConfigModule:
      def threadCount = 50
      def operationCount = 100
    end wideConfig
  end brown_ext_chromatic_augment_lf

  trait SetBenchTracingConfigModule extends TracingConfigModule:
    def commitHashDir: T[PathRef]
    def specToValidate = spec()
    def specToValidateMC =
      Task.Source(setbench.moduleDir / "MCChromaticTreeValidate.tla")
    def specToValidateMCConfig =
      Task.Source(setbench.moduleDir / "MCChromaticTreeValidate.cfg")

    def dsSubFolder: T[os.SubPath]

    def buildDirOpt = Some(buildDir())
    def buildDir: T[PathRef] = Task:
      val src = commitHashDir().path
      val includes = List(
        src / "common",
        src / "common" / "recordmgr",
        src / dsSubFolder(),
        specHPP().path / os.up,
        omnilinkLibHPP().path / os.up,
      )
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          deriv().path,
          "-c",
          "cmake",
          s"-DOMNILINK_INCLUDE_DIRS=${includes.mkString(";")}",
          cmakeLists().path / os.up,
          // "g++",
          // "-g",
          // "-O3",
          // includes.map(i => s"-I$i"),
          // mainCPP().path,
          // "-o",
          // exeDest,
        ),
        cwd = Task.dest,
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(Task.dest)
    end buildDir

    def tracingExecutable: T[PathRef] = Task:
      val exeDest = buildDir().path / "main"
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          deriv().path,
          "-c",
          "cmake",
          "--build",
          buildDir(),
        ),
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(exeDest)
    end tracingExecutable

    def validateConfigDir: T[PathRef] =
      Task.Source(setbench.moduleDir / "validate_cfg")
  end SetBenchTracingConfigModule
end setbench
