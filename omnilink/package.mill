package build.omnilink

import mill.*
import mill.util.Jvm
import mill.api.{BuildCtx, ModuleRef}
import mill.api.Evaluator
import mill.api.Task.Simple

trait TraceEvalSpecModule extends Module:
  def spec: T[PathRef]
  def specHPP: T[PathRef] = Task:
    val destFile = Task.dest / "workload-meta.hpp"
    build.omnilink.tool
      .runner()
      .run(
        List[os.Shellable](
          "gen-hpp",
          spec().path,
          "--out-file",
          destFile,
        ),
      )
    PathRef(destFile)
  end specHPP
end TraceEvalSpecModule

def omnilinkInclude: T[PathRef] =
  Task.Source(os.sub / "include")

object wiredtiger extends TraceEvalSpecModule:
  def deriv: T[PathRef] = Task.Source(os.sub)

  def spec = Task.Source(os.sub / "Storage.tla")
  def cmakeLists = Task.Source(os.sub / "CMakeLists.txt")

  object release_11_3_1 extends WTTracingConfigModule:
    def wtVersion = "v11_3_1"
    def specToValidate = spec()
    def specToValidateMC =
      Task.Source(wiredtiger.moduleDir / "MCStorageValidate.tla")
    def specToValidateMCConfig =
      Task.Source(wiredtiger.moduleDir / "MCStorageValidate.cfg")

    object defaultConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 100
    end defaultConfig
    object longConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 10000
    end longConfig
    object wideConfig extends ConfigModule:
      def threadCount = 50
      def operationCount = 100
    end wideConfig
  end release_11_3_1

  trait WTTracingConfigModule extends TracingConfigModule:
    def wtVersion: T[String]

    def buildDirOpt = Some(buildDir())
    def buildDir: T[PathRef] = Task:
      val includes = List(
        specHPP().path / os.up,
        omnilinkInclude().path,
      )
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          s"${deriv().path}#${wtVersion()}",
          "-c",
          "cmake",
          s"-DOMNILINK_INCLUDE_DIRS=${includes.mkString(";")}",
          cmakeLists().path / os.up,
        ),
        cwd = Task.dest,
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(Task.dest)
    end buildDir

    def tracingExecutable: T[PathRef] = Task:
      val exeDest = buildDir().path / "main"
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          s"${deriv().path}#${wtVersion()}",
          "-c",
          "cmake",
          "--build",
          buildDir(),
        ),
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(exeDest)
    end tracingExecutable
  end WTTracingConfigModule
end wiredtiger

object setbench extends TraceEvalSpecModule:
  object repo extends GitRepoModule:
    def origin = "git@github.com:ubc-systopia/augmented-chromatic-trees.git"
    object paper1 extends CommitHash:
      def commitHash = "cb4562bb8459b848685738fb1f00c2a015b56be2"
  end repo
  def spec = Task.Source(os.sub / "ChromaticTree.tla")
  def cmakeLists = Task.Source(os.sub / "CMakeLists.txt")
  // def mainCPP = Task.Source(os.sub / "main.cpp")

  def deriv: T[PathRef] = Task.Source(os.sub)

  object brown_ext_chromatic_augment_lf extends SetBenchTracingConfigModule:
    def dsSubFolder = os.sub / "ds" / "brown_ext_chromatic_augment_lf"
    def commitHashDir = repo.paper1.dir()

    object defaultConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 100
    end defaultConfig
    object longConfig extends ConfigModule:
      def threadCount = 5
      def operationCount = 100000
    end longConfig
    object wideConfig extends ConfigModule:
      def threadCount = 50
      def operationCount = 100
    end wideConfig

    trait opCountScanModule extends Cross.Module[Int], ConfigModule:
      def threadCount = 5
      def operationCount = crossValue
    end opCountScanModule

    object opCountScan extends Cross[opCountScanModule](100 to 100000 by 10000)
  end brown_ext_chromatic_augment_lf

  trait SetBenchTracingConfigModule extends TracingConfigModule:
    def commitHashDir: T[PathRef]
    def specToValidate = spec()
    def specToValidateMC =
      Task.Source(setbench.moduleDir / "MCChromaticTreeValidate.tla")
    def specToValidateMCConfig =
      Task.Source(setbench.moduleDir / "MCChromaticTreeValidate.cfg")
    def porcupineBenchName = "setbench"

    def dsSubFolder: T[os.SubPath]

    def buildDirOpt = Some(buildDir())
    def buildDir: T[PathRef] = Task:
      val src = commitHashDir().path
      val includes = List(
        src / "common",
        src / "common" / "recordmgr",
        src / dsSubFolder(),
        specHPP().path / os.up,
        omnilinkInclude().path,
      )
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          deriv().path,
          "-c",
          "cmake",
          s"-DOMNILINK_INCLUDE_DIRS=${includes.mkString(";")}",
          cmakeLists().path / os.up,
        ),
        cwd = Task.dest,
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(Task.dest)
    end buildDir

    def tracingExecutable: T[PathRef] = Task:
      val exeDest = buildDir().path / "main"
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          deriv().path,
          "-c",
          "cmake",
          "--build",
          buildDir(),
        ),
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(exeDest)
    end tracingExecutable
  end SetBenchTracingConfigModule
end setbench

object concurrentqueue extends TraceEvalSpecModule:
  def spec = Task.Source(os.sub / "ConcurrentQueueAPI.tla")
  def cmakeLists = Task.Source(os.sub / "CMakeLists.txt")
  def deriv: T[PathRef] = Task.Source(os.sub)

  object v1_0_4 extends CQTracingConfigModule:
    def cqVersion: Simple[String] = "v1_0_4"
    def specToValidate = spec()
    def specToValidateMC = Task.Source(
      concurrentqueue.moduleDir / "MCConcurrentQueueAPIValidate.tla",
    )
    def specToValidateMCConfig = Task.Source(
      concurrentqueue.moduleDir / "MCConcurrentQueueAPIValidate.cfg",
    )

    object defaultConfig extends ConfigModule:
      def threadCount = 2
      def operationCount = 1
    end defaultConfig
  end v1_0_4

  trait CQTracingConfigModule extends TracingConfigModule:
    def cqVersion: T[String]

    def buildDirOpt = Some(buildDir())
    def buildDir: T[PathRef] = Task:
      val includes = List(
        specHPP().path / os.up,
        omnilinkInclude().path,
      )
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          s"${deriv().path}#${cqVersion()}",
          "-c",
          "cmake",
          s"-DOMNILINK_INCLUDE_DIRS=${includes.mkString(";")}",
          cmakeLists().path / os.up,
        ),
        cwd = Task.dest,
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(Task.dest)
    end buildDir

    def tracingExecutable: T[PathRef] = Task:
      val exeDest = buildDir().path / "main"
      os.call(
        List[os.Shellable](
          nativebuilds.Nix.nixExe(),
          "develop",
          s"${deriv().path}#${cqVersion()}",
          "-c",
          "cmake",
          "--build",
          buildDir(),
        ),
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(exeDest)
    end tracingExecutable
  end CQTracingConfigModule
end concurrentqueue
