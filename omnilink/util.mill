package build.omnilink

import mill.*
import mill.api.{ModuleRef, BuildCtx}
import scala.util.Using
import java.time.LocalDateTime

import build.omnilink.evaldb.EvalDB, EvalDB.given

import scalasql.*, PostgresDialect.*
import mill.api.Cross.ToSegments
import java.time.Duration
import mill.api.Evaluator
import scala.collection.immutable.ArraySeq

private object ValidateConcurrencyLimiter:
  private var usageCount = 0

  def apply(concurrencyLimit: Int): Handle =
    ValidateConcurrencyLimiter.synchronized:
      while usageCount >= concurrencyLimit
      do ValidateConcurrencyLimiter.wait()
      usageCount += 1
      println("got concurrency token")
      Handle()
  end apply

  final class Handle private[ValidateConcurrencyLimiter] ()
      extends AutoCloseable:
    def close(): Unit =
      ValidateConcurrencyLimiter.synchronized:
        println("giving up concurrency token")
        ValidateConcurrencyLimiter.notifyAll()
        usageCount -= 1
  end Handle
end ValidateConcurrencyLimiter

trait TracingConfigModule extends Module:
  tracingConfig =>
  def tracingExecutable: T[PathRef]

  def specToValidate: T[PathRef]
  def specToValidateMC: T[PathRef]
  def specToValidateMCConfig: T[PathRef]

  // Weird trick: because this is all macro expansion, if someone uses Mill ops inside
  // fn, they get expanded after us, so they can't tell we skipped using Task.Anon
  private inline def inDBTransaction[T](
      inline fn: scalasql.core.DbApi.Txn => T,
  ): T =
    Using.resource(EvalDB.dbClient()): db =>
      db.transaction(fn)
  end inDBTransaction

  trait ConfigModule extends Module:
    configModule =>
    def threadCount: Int
    def operationCount: Int

    val configId: String =
      configModule.moduleSegments.render

    private val indices: List[Int] = BuildCtx.watchValue:
      inDBTransaction: db =>
        db.run:
          EvalDB.Config.insert
            .columns(
              _.id := configId,
              _.expectedExperimentCount := 0,
            )
            .onConflictIgnore(_.id)

        val expectedExperimentCount: Int = db.run:
          EvalDB.Config.select
            .filter(_.id === configId)
            .map(_.expectedExperimentCount)
            .single
        val actualExperimentCount: Int = db.run:
          EvalDB.Experiment.select
            .filter(_.configId === configId)
            .map(_.idx)
            .max + 1
        val tracesNeeded = expectedExperimentCount.max(actualExperimentCount)

        (0 until tracesNeeded).toList
    end indices

    def expectedTraceCount = Task.Input:
      indices.size
    end expectedTraceCount

    def setExpectedTraceCount(@mainargs.arg(positional = true) count: Int) =
      Task.Command[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Config
              .update(_.id === configId)
              .set(_.expectedExperimentCount := count)
          ()
    end setExpectedTraceCount

    def counterExamples(eval: Evaluator) = Task.Command(exclusive = true)[Unit]:
      val traceMods = indices.map(traces(_))
      val result = eval.execute(traceMods.map(_.counterExample))
      os.list(BuildCtx.workspaceRoot)
        .filter(os.isFile)
        .filter(_.last.startsWith(configId))
        .foreach: existingFile =>
          println(s"cleanup $existingFile")
          os.remove(existingFile)
      println("counterexamples:")
      result.values.get.flatten
        .foreach: (traceId, eg, tags) =>
          val destPath = BuildCtx.workspaceRoot / s"$traceId.bin"
          os.copy.over(from = eg.path, to = destPath)
          println(s"  $traceId:")
          tags.foreach: tag =>
            println(s"    $tag")
    end counterExamples

    object traces extends Cross[TraceModule](indices)

    trait TraceModule extends Cross.Module[Int]:
      traceModule =>
      def experimentIdx = crossValue
      def traceId = traceModule.moduleSegments.render

      def counterExample: T[Option[(String, PathRef, List[String])]] = Task:
        val egPath = Task.dest / "counterExample.bin"
        inDBTransaction: db =>
          val egs = db.run:
            EvalDB.Validation.select
              .filter(_.configId === configId)
              .filter(_.experimentIdx === experimentIdx)
              .filter(row => !row.success)
              .map(_.counterExampleBin)
              .take(1)
          val eg = egs.flatten.headOption
          eg match
            case None => None
            case Some(bytes) =>
              os.write(egPath, bytes.array)
              // val toolClasspath = build.omnilink.tool
              //   .runClasspath()
              //   .map(_.path.toString())
              //   .mkString(":")
              // val toolProc = os.proc(
              //   mill.util.Jvm.javaExe,
              //   build.omnilink.tool.forkArgs(),
              //   "-cp",
              //   toolClasspath,
              //   "omnilink.Tool",
              //   "triage",
              //   unpackValidationEnv().path / specToValidateMC().path.last,
              //   egPath,
              // )
              // val result = toolProc.call()
              // val tags = result.out.lines()
              Some((traceId, PathRef(egPath), List[String]()))
      end counterExample

      def trace = Task.Input[List[ArraySeq[Byte]]]:
        inDBTransaction: db =>
          db
            .stream:
              EvalDB.Trace.select
                .filter(_.configId === configId)
                .filter(_.experimentIdx === experimentIdx)
                .sortBy(_.id)
                .map(_.trace)
            .map(_.array)
            .map(ArraySeq.unsafeWrapArray)
            .toList
      end trace

      def unpackTrace = Task[PathRef]:
        trace().zipWithIndex
          .foreach: (trace, idx) =>
            val file = Task.dest / s"tracing-$idx.log"
            println(s"extracting log $idx to $file")
            os.write(file, trace.toArray)
        PathRef(Task.dest)
      end unpackTrace

      def unpackValidationEnv = Task[PathRef]:
        val tracesFolder = unpackTrace().path
        val spec = specToValidate().path
        val mcSpec = specToValidateMC().path
        val mcConfig = specToValidateMCConfig().path

        build.omnilink.tool
          .runner()
          .run(
            List[os.Shellable](
              "gen-tla",
              spec,
              tracesFolder,
              "--dest-dir",
              Task.dest,
            ),
          )

        os.copy(from = mcSpec, to = Task.dest / mcSpec.last)
        os.copy(from = mcConfig, to = Task.dest / mcConfig.last)
        PathRef(Task.dest)
      end unpackValidationEnv

      def discardTrace() = Task.Command(exclusive = true)[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Validation
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
          db.run:
            EvalDB.Trace
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
          db.run:
            EvalDB.GatherLog
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
        // Extra transaction, because ??? need it to pass foreign key check
        inDBTransaction: db =>
          db.run:
            EvalDB.Experiment
              .delete: row =>
                row.configId === configId
                  && row.idx === experimentIdx
        ()
      end discardTrace

      def discardValidation() = Task.Command[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Validation
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx

          ()
      end discardValidation

      def discardNegativeValidation() = Task.Command[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Validation
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
                  && !row.success

          ()
      end discardNegativeValidation

      def gatherTrace() = Task.Command(exclusive = true)[Unit]:
        val exe = tracingExecutable()

        inDBTransaction: db =>
          if db.run:
              EvalDB.Experiment.select
                .filter(_.configId === configId)
                .filter(_.idx === experimentIdx)
                .size > 0
          then println(s"already gathered trace $traceId")
          else
            println(s"gathering trace $traceId")

            val rrTracesDir = Task.dest / "rr"
            os.makeDir.all(rrTracesDir)

            val startTime = LocalDateTime.now()
            val result = os
              .proc(
                build.omnilink.nativebuilds.rr.bin.out(),
                "record",
                "-W",
                // "-n", // this was breaking replay, instead we set trace events properly
                "--chaos",
                "--",
                exe,
              )
              .call(
                cwd = Task.dest,
                mergeErrIntoOut = true,
                check = false,
                env = Map(
                  "_RR_TRACE_DIR" -> rrTracesDir.toString(),
                  "OMNILINK_OPERATIONS" -> operationCount.toString(),
                  "OMNILINK_THREADS" -> threadCount.toString(),
                ),
              )
            val endTime = LocalDateTime.now()
            result.out.lines().foreach(println)

            // Note: we don't really lose much from disabling this; we can also capture
            //       a full impl replay of any crashes. We record the code below.
            // if result.exitCode != 0
            // then
            //   println(
            //     s"saw exit code ${result.exitCode}; check in ${Task.dest}",
            //   )
            //   throw RuntimeException("trace collection failed")

            val rrLatestTrace = rrTracesDir / "latest-trace"
            os.call(
              List[os.Shellable](
                build.omnilink.nativebuilds.rr.bin.out(),
                "pack",
                rrLatestTrace,
              ),
              stdout = os.Inherit,
              stderr = os.Inherit,
            )
            val rrZipFile = Task.dest / "rr.zip"
            os.zip(rrZipFile, Seq(rrLatestTrace))

            db.run:
              EvalDB.Experiment.insert
                .columns(
                  _.configId := configId,
                  _.idx := experimentIdx,
                  _.specPath := specToValidate().path,
                  _.mcSpecPath := specToValidateMC().path,
                  _.mcConfigPath := specToValidateMCConfig().path,
                  _.startTime := startTime,
                  _.endTime := endTime,
                  _.exitCode := result.exitCode,
                  _.rrZip := geny.Bytes(os.read.bytes(rrZipFile)),
                )

            db.run:
              EvalDB.GatherLog.insert
                .columns(
                  _.configId := configId,
                  _.experimentIdx := experimentIdx,
                  _.name := "stdout",
                  _.text := result.out.text(),
                )
            os.list(Task.dest)
              .sortBy(_.last)
              .filter(_.last.endsWith(".log"))
              .zipWithIndex
              .foreach: (file, id) =>
                db.run:
                  EvalDB.Trace.insert
                    .columns(
                      _.configId := configId,
                      _.experimentIdx := experimentIdx,
                      _.id := id,
                      _.trace := geny.Bytes(os.read.bytes(file)),
                    )
            ()
      end gatherTrace

      def concurrencyLimit = Task.Input:
        Task.ctx().env.get("TLC_CONCURRENCY").fold(1)(_.toInt)

      def validateTrace() = Task.Command[Unit]:
        inDBTransaction: db =>
          if db.run:
              EvalDB.Validation.select
                .filter(_.configId === configId)
                .filter(_.experimentIdx === experimentIdx)
                .size > 0
          then println(s"already validated trace $traceId")
          else
            Using.resource(ValidateConcurrencyLimiter(concurrencyLimit())): _ =>
              val validationDir = unpackValidationEnv().path
              os.copy.over(
                validationDir,
                Task.dest,
                replaceExisting = true,
                createFolders = true,
              )
              val startTime = LocalDateTime.now()
              val tlcClasspath =
                build.tlc
                  .runClasspath()
                  .map(_.path.toString())
                  .mkString(":")
              val tlcProc = os.proc(
                mill.util.Jvm.javaExe,
                "-XX:+UseParallelGC",
                "-cp",
                tlcClasspath,
                "tlc2.TLC",
                "-gzip",
                "-noGenerateSpecTE",
                "-dump",
                "class,pgo.util.CaptureCounterExamples",
                Task.dest / specToValidateMC().path.last,
              )

              val tlcOutFile = Task.dest / "tlc_output.txt"
              var isError = false
              val tlcResult = tlcProc.call(
                cwd = Task.dest,
                check = false,
                stdout = os.ProcessOutput.Readlines: line =>
                  def out(line: String): Unit =
                    os.write
                      .append(target = tlcOutFile, data = List(line, "\n"))
                    println(line)
                  if line.startsWith(
                      "Error: The behavior up to this point is:",
                    )
                  then
                    isError = true
                    out(line) // show the error line
                    out("(omitting counterexample...)")
                  if line.endsWith(" states left on queue.")
                  then isError = false
                  if !isError
                  then out(line)
                ,
                mergeErrIntoOut = true,
              )

              val endTime = LocalDateTime.now()
              val counterExampleFile =
                Task.dest / "CaptureCounterExamples.bin"

              val counterExampleBinOpt =
                if tlcResult.exitCode != 0
                then
                  if os.exists(counterExampleFile)
                  then Some(os.read.bytes(counterExampleFile))
                  else Some(upack.writeToByteArray(upack.Arr()))
                else None

              println(
                s"trace $traceId validation --> TLC code ${tlcResult.exitCode}, ${Duration.between(startTime, endTime).toMinutes()}min",
              )

              db.run:
                EvalDB.Validation.insert
                  .columns(
                    _.configId := configId,
                    _.experimentIdx := experimentIdx,
                    _.counterExampleBin := counterExampleBinOpt
                      .map(geny.Bytes(_)),
                    _.logTxt := os.read(tlcOutFile),
                    _.success := tlcResult.exitCode == 0,
                    _.startTime := startTime,
                    _.endTime := endTime,
                  )
              ()
      end validateTrace

      def tsVizRaw() = Task.Command[Unit]:
        val logsDir = unpackTrace().path
        build.omnilink.tool
          .runner()
          .run(
            List[os.Shellable](
              "showlog",
              "tsviz",
              logsDir,
              BuildCtx.workspaceRoot / s"$traceId.tsviz",
            ),
          )
      end tsVizRaw

      def rrZipFile: T[PathRef] = Task:
        inDBTransaction: db =>
          val bytes = db.run:
            EvalDB.Experiment.select
              .filter(_.configId === configId)
              .filter(_.idx === experimentIdx)
              .map(_.rrZip)
              .single

          val dest = Task.dest / "rr.zip"
          os.write(dest, bytes.array)
          PathRef(dest)
      end rrZipFile

      def rrTraceDir: T[PathRef] = Task:
        os.unzip(rrZipFile().path, Task.dest)
        PathRef(Task.dest)
      end rrTraceDir

      def rrReplay() = Task.Command(exclusive = true)[Unit]:
        if !mill.constants.Util.hasConsole()
        then
          Task.fail("rrReplay needs to be run with the -i/--interactive flag")
        os.call(
          List[os.Shellable](
            build.omnilink.nativebuilds.rr.bin.out(),
            "replay",
            "-W",
            rrTraceDir(),
          ),
          stdout = os.Inherit,
          stderr = os.Inherit,
          stdin = os.Inherit,
        )
      end rrReplay
    end TraceModule
  end ConfigModule
end TracingConfigModule
