package build.omnilink

import mill.*
import mill.api.{ModuleRef, BuildCtx}
import scala.util.Using
import java.time.LocalDateTime

import EvalDB.given

import scalasql.*, PostgresDialect.*
import mill.api.Cross.ToSegments
import java.time.temporal.TemporalUnit
import java.time.Duration
import mill.api.Evaluator

private object ValidateConcurrencyLimiter:
  private var usageCount = 0

  def apply() = Task.Anon[Handle]:
    ValidateConcurrencyLimiter.synchronized:
      val concurrencyLimit =
        Task.ctx().env.get("TLC_CONCURRENCY").fold(1)(_.toInt)
      while usageCount >= concurrencyLimit
      do ValidateConcurrencyLimiter.wait()
      usageCount += 1
      println("got concurrency token")
      Handle()
  end apply

  final class Handle private[ValidateConcurrencyLimiter] ()
      extends AutoCloseable:
    def close(): Unit =
      ValidateConcurrencyLimiter.synchronized:
        println("giving up concurrency token")
        ValidateConcurrencyLimiter.notifyAll()
        usageCount -= 1
  end Handle
end ValidateConcurrencyLimiter

trait TracingConfig extends Module:
  self =>
  def evalDB: ModuleRef[EvalDB]
  def commitHash: ModuleRef[build.omnilink.GitRepo#CommitHash]
  def tracingExecutable: T[PathRef]

  def specToValidate: T[PathRef]
  def specToValidateMC: T[PathRef]
  def specToValidateMCConfig: T[PathRef]

  final case class Config(
      threadCount: Int,
      operationCount: Int,
      tracesNeeded: Int,
  )
  object Config:
    given ToSegments[Config] = ToSegments: config =>
      List(s"threads_${config.threadCount}", s"ops_${config.operationCount}")
  end Config

  def configs: Seq[Config]

  private def indexedConfigs =
    configs.flatMap: config =>
      (0 until config.tracesNeeded).map((_, config))

  def counterExamples(eval: Evaluator) = Task.Command(exclusive = true)[Unit]:
    val traceMods = indexedConfigs.map((idx, cfg) => traces(idx, cfg))
    val result = eval.execute(traceMods.map(_.counterExample))
    println("counterexamples:")
    result.values.get.flatten
      .foreach: (eg, tags) =>
        println(s"${eg.path}:")
        tags.foreach: tag =>
          println(s"  $tag")
  end counterExamples

  object traces extends Cross[TraceModule](indexedConfigs)

  trait TraceModule extends Cross.Module2[Int, Config]:
    traceModule =>
    def experimentIndex = crossValue
    def threadCount = crossValue2.threadCount
    def operationCount = crossValue2.operationCount

    def experimentId: T[String] =
      traceModule.moduleSegments.render

    def counterExample: T[Option[(PathRef, List[String])]] = Task:
      unpackValidationEnv()
      val egPath = Task.dest / "counterExample.bin"
      Using.resource(evalDB().dbClient()()): db =>
        db.transaction: db =>
          val egs = db.run:
            EvalDB.Validation.select
              .filter: row =>
                row.experimentId === experimentId()
                  && !row.success
              .map(_.counterExampleBin)
              .take(1)
          val eg = egs.flatten.headOption
          eg match
            case None => None
            case Some(bytes) =>
              os.write(egPath, bytes.array)
              val toolClasspath = build.omnilink.tool
                .runClasspath()
                .map(_.path.toString())
                .mkString(":")
              val toolProc = os.proc(
                mill.util.Jvm.javaExe,
                build.omnilink.tool.forkArgs(),
                "-cp",
                toolClasspath,
                "omnilink.Tool",
                "triage",
                Task.dest / specToValidateMC().path.last,
                egPath,
              )
              val result = toolProc.call()
              val tags = result.out.lines()
              Some((PathRef(egPath), tags.toList))
    end counterExample

    private def extractTrace = Task.Anon[PathRef]:
      Using.resource(evalDB().dbClient()()): db =>
        db.transaction: db =>
          db
            .stream:
              EvalDB.Trace.select
                .filter(_.experimentId === experimentId())
                .sortBy(_.id)
                .map(_.trace)
            .zipWithIndex
            .foreach: (trace, idx) =>
              val file = Task.dest / s"tracing-$idx.log"
              println(s"extracting log $idx to $file")
              os.write(file, trace.array)
          PathRef(Task.dest)
    end extractTrace

    private def unpackValidationEnv = Task.Anon[Unit]:
      val tracesFolder = extractTrace()
      val spec = specToValidate().path
      val mcSpec = specToValidateMC().path
      val mcConfig = specToValidateMCConfig().path

      build.omnilink.tool
        .runner()
        .run(
          List[os.Shellable](
            "gen-tla",
            spec,
            tracesFolder,
            "--dest-dir",
            Task.dest,
          ),
        )

      os.copy(from = mcSpec, to = Task.dest / mcSpec.last)
      os.copy(from = mcConfig, to = Task.dest / mcConfig.last)
    end unpackValidationEnv

    def discardValidation() = Task.Command[Unit]:
      Using.resource(evalDB().dbClient()()): db =>
        db.transaction: db =>
          db.run:
            EvalDB.Validation
              .delete(_.experimentId === experimentId())

          ()
    end discardValidation

    def gatherTrace() = Task.Command(exclusive = true)[PathRef]:
      val exe = tracingExecutable()

      Using.resource(evalDB().dbClient()()): db =>
        db.transaction: db =>
          if db.run:
              EvalDB.Experiment.select
                .filter(_.id === experimentId())
                .size > 0
          then
            println(s"already gathered trace $experimentId")
            extractTrace()
          else
            println(s"gathering trace $experimentId")

            val startTime = LocalDateTime.now()
            val result = os
              .proc(exe)
              .call(
                cwd = Task.dest,
                mergeErrIntoOut = true,
                check = false,
                env = Map(
                  "OMNILINK_OPERATIONS" -> operationCount.toString(),
                  "OMNILINK_THREADS" -> threadCount.toString(),
                ),
              )
            val endTime = LocalDateTime.now()
            result.out.lines().foreach(println)

            if result.exitCode != 0
            then
              println(
                s"saw exit code ${result.exitCode}; check in ${Task.dest}",
              )
              throw RuntimeException("trace collection failed")

            db.run:
              EvalDB.Experiment.insert
                .columns(
                  _.id := experimentId(),
                  _.github := commitHash().origin(),
                  _.branch := commitHash().commitHash(),
                  _.specPath := specToValidate().path,
                  _.mcSpecPath := specToValidateMC().path,
                  _.mcConfigPath := specToValidateMCConfig().path,
                  _.startTime := startTime,
                  _.endTime := endTime,
                )

            db.run:
              EvalDB.GatherLog.insert
                .columns(
                  _.experimentId := experimentId(),
                  _.name := "stdout",
                  _.text := result.out.text(),
                )
            os.list(Task.dest)
              .sortBy(_.last)
              .filter(_.last.endsWith(".log"))
              .zipWithIndex
              .foreach: (file, id) =>
                db.run:
                  EvalDB.Trace.insert
                    .columns(
                      _.experimentId := experimentId(),
                      _.id := id,
                      _.trace := geny.Bytes(os.read.bytes(file)),
                    )
            PathRef(Task.dest)
    end gatherTrace

    def validateTrace() = Task.Command[Unit]:
      Using.resource(ValidateConcurrencyLimiter()()): _ =>
        Using.resource(evalDB().dbClient()()): db =>
          db.transaction: db =>
            if db.run:
                EvalDB.Validation.select
                  .filter(_.experimentId === experimentId())
                  .size > 0
            then println(s"already validated trace ${experimentId()}")
            else
              val startTime = LocalDateTime.now()
              unpackValidationEnv()
              val tlcClasspath =
                build.tlc.runClasspath().map(_.path.toString()).mkString(":")
              val tlcProc = os.proc(
                mill.util.Jvm.javaExe,
                "-XX:+UseParallelGC",
                "-cp",
                tlcClasspath,
                "tlc2.TLC",
                "-generateSpecTE",
                Task.dest / specToValidateMC().path.last,
              )

              val tlcOutFile = Task.dest / "tlc_output.txt"
              var isError = false
              val tlcResult = tlcProc.call(
                cwd = Task.dest,
                check = false,
                stdout = os.ProcessOutput.Readlines: line =>
                  def out(line: String): Unit =
                    os.write
                      .append(target = tlcOutFile, data = List(line, "\n"))
                    println(line)
                  if line.startsWith("Error: The behavior up to this point is:")
                  then
                    isError = true
                    out(line) // show the error line
                    out("(omitting counterexample...)")
                  if line.endsWith(" states left on queue.")
                  then isError = false
                  if !isError
                  then out(line)
                ,
                mergeErrIntoOut = true,
              )

              val endTime = LocalDateTime.now()

              val counterExampleBinOpt =
                if tlcResult.exitCode != 0
                then
                  os.list(Task.dest)
                    .filter(_.last.contains("TTrace"))
                    .filter(_.last.endsWith(".bin"))
                    .headOption
                else None

              println(
                s"trace ${experimentId()} validation --> TLC code ${tlcResult.exitCode}, ${Duration.between(startTime, endTime).toMinutes()}min",
              )
              if counterExampleBinOpt.nonEmpty then
                println(s"counterexample: ${counterExampleBinOpt.get}")

              db.run:
                EvalDB.Validation.insert
                  .columns(
                    _.experimentId := experimentId(),
                    _.counterExampleBin := counterExampleBinOpt
                      .map(os.read.bytes(_))
                      .map(geny.Bytes(_)),
                    _.logTxt := os.read(tlcOutFile),
                    _.success := tlcResult.exitCode == 0,
                    _.startTime := startTime,
                    _.endTime := endTime,
                  )
              ()
    end validateTrace
  end TraceModule
end TracingConfig

trait EvalDB extends Module:
  def dbPath: os.SubPath
  def createTablesSQL: T[PathRef]

  final case class AutoCloseClient(client: DbClient, closeFn: () => Unit)
      extends AutoCloseable:
    export client.*
    def close(): Unit =
      closeFn()
  end AutoCloseClient

  def dbClient: Task[() => AutoCloseClient] = Task.Worker:
    Class.forName("org.duckdb.DuckDBDriver")
    val fn = () =>
      val conn = java.sql.DriverManager.getConnection(
        s"jdbc:duckdb:${BuildCtx.workspaceRoot / dbPath}",
      )
      val client = DbClient.Connection(conn)
      AutoCloseClient(client, conn.close)
    Using.resource(fn()): conn =>
      conn.getAutoCommitClientConnection
        .updateRaw(os.read(createTablesSQL().path))

    fn
  end dbClient
end EvalDB

object EvalDB:
  given workspacePathMapper: TypeMapper[os.Path] =
    TypeMapper[String].bimap(
      _.relativeTo(BuildCtx.workspaceRoot).toString,
      os.Path(_, BuildCtx.workspaceRoot),
    )

  case class Experiment[T[_]](
      id: T[String],
      github: T[String],
      branch: T[String],
      specPath: T[os.Path],
      mcSpecPath: T[os.Path],
      mcConfigPath: T[os.Path],
      startTime: T[LocalDateTime],
      endTime: T[LocalDateTime],
  )
  object Experiment extends Table[Experiment]

  case class Trace[T[_]](
      experimentId: T[String],
      id: T[Int],
      trace: T[geny.Bytes],
  )
  object Trace extends Table[Trace]

  case class GatherLog[T[_]](
      experimentId: T[String],
      name: T[String],
      text: T[String],
  )
  object GatherLog extends Table[GatherLog]

  case class Validation[T[_]](
      experimentId: T[String],
      logTxt: T[String],
      startTime: T[LocalDateTime],
      endTime: T[LocalDateTime],
      success: T[Boolean],
      counterExampleBin: T[Option[geny.Bytes]],
  )
  object Validation extends Table[Validation]
end EvalDB
