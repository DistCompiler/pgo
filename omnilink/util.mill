package build.omnilink

import mill.*
import mill.api.{ModuleRef, BuildCtx}
import scala.util.Using
import java.time.LocalDateTime

import build.omnilink.evaldb.EvalDB, EvalDB.given

import scalasql.*, PostgresDialect.*
import mill.api.Cross.ToSegments
import java.time.Duration
import mill.api.Evaluator
import scala.collection.immutable.ArraySeq

private object ValidateConcurrencyLimiter:
  private var usageCount = 0

  def apply(concurrencyLimit: Int): Handle =
    ValidateConcurrencyLimiter.synchronized:
      while usageCount >= concurrencyLimit
      do ValidateConcurrencyLimiter.wait()
      usageCount += 1
      println("got concurrency token")
      Handle()
  end apply

  final class Handle private[ValidateConcurrencyLimiter] ()
      extends AutoCloseable:
    def close(): Unit =
      ValidateConcurrencyLimiter.synchronized:
        println("giving up concurrency token")
        ValidateConcurrencyLimiter.notifyAll()
        usageCount -= 1
  end Handle
end ValidateConcurrencyLimiter

trait TracingConfigModule extends Module:
  tracingConfig =>
  def buildDirOpt: T[Option[PathRef]] = None
  def tracingExecutable: T[PathRef]

  def specToValidate: T[PathRef]
  def specToValidateMC: T[PathRef]
  def specToValidateMCConfig: T[PathRef]

  def installCompileCommands() = Task.Command[Unit]:
    buildDirOpt() match
      case None => // nothing
      case Some(dir) =>
        val cmdsFile = dir.path / "compile_commands.json"
        if os.isFile(cmdsFile)
        then
          var dir = tracingConfig.moduleDir
          while dir.startsWith(BuildCtx.workspaceRoot) && !os.isFile(
              dir / "CMakeLists.txt",
            )
          do dir = dir / os.up

          if os.isFile(dir / "CMakeLists.txt")
          then os.copy.over(cmdsFile, dir / "compile_commands.json")
  end installCompileCommands

  // Weird trick: because this is all macro expansion, if someone uses Mill ops inside
  // fn, they get expanded after us, so they can't tell we skipped using Task.Anon
  private inline def inDBTransaction[T](
      inline fn: scalasql.core.DbApi.Txn => T,
  ): T =
    Using.resource(EvalDB.dbClient()): db =>
      db.transaction(fn)
  end inDBTransaction

  trait ConfigModule extends Module:
    configModule =>
    def threadCount: Int
    def operationCount: Int
    def defaultTracesNeeded: Int = 10

    val configId: String =
      configModule.moduleSegments.render

    private val indices: List[Int] = BuildCtx.watchValue:
      inDBTransaction: db =>
        db.run:
          EvalDB.Config.insert
            .columns(
              _.id := configId,
              _.expectedExperimentCount := 0,
            )
            .onConflictIgnore(_.id)

        val expectedExperimentCount: Int = db.run:
          EvalDB.Config.select
            .filter(_.id === configId)
            .map(_.expectedExperimentCount)
            .single
        val actualExperimentCount: Int = db.run:
          EvalDB.Experiment.select
            .filter(_.configId === configId)
            .map(_.idx)
            .max + 1
        val tracesNeeded = expectedExperimentCount
          .max(actualExperimentCount)
          .max(defaultTracesNeeded)

        (0 until tracesNeeded).toList
    end indices

    def expectedTraceCount = Task.Input:
      indices.size
    end expectedTraceCount

    def setExpectedTraceCount(@mainargs.arg(positional = true) count: Int) =
      Task.Command[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Config
              .update(_.id === configId)
              .set(_.expectedExperimentCount := count)
          ()
    end setExpectedTraceCount

    def counterExamples(eval: Evaluator) = Task.Command(exclusive = true)[Unit]:
      val traceMods = indices.map(traces(_))
      val result = eval.execute(traceMods.map(_.counterExample))
      os.list(BuildCtx.workspaceRoot)
        .filter(os.isFile)
        .filter(_.last.startsWith(configId))
        .foreach: existingFile =>
          println(s"cleanup $existingFile")
          os.remove(existingFile)
      println("counterexamples:")
      result.values.get.flatten
        .foreach: (traceId, eg, tags) =>
          val destPath = BuildCtx.workspaceRoot / s"$traceId.bin"
          os.copy.over(from = eg.path, to = destPath)
          println(s"  $traceId:")
          tags.foreach: tag =>
            println(s"    $tag")
    end counterExamples

    object traces extends Cross[TraceModule](indices)

    trait TraceModule extends Cross.Module[Int]:
      traceModule =>
      def experimentIdx = crossValue
      def traceId = traceModule.moduleSegments.render

      def counterExampleHash: T[Int] = Task.Input:
        inDBTransaction: db =>
          val egs = db.run:
            EvalDB.Validation.select
              .filter(_.configId === configId)
              .filter(_.experimentIdx === experimentIdx)
              .filter(row => !row.success)
              .map(_.counterExampleBin)
              .take(1)
          egs.flatten.headOption.hashCode
      end counterExampleHash

      def counterExample: T[Option[(String, PathRef, List[String])]] = Task:
        counterExampleHash()
        val egPath = Task.dest / "counterExample.bin"
        inDBTransaction: db =>
          val egs = db.run:
            EvalDB.Validation.select
              .filter(_.configId === configId)
              .filter(_.experimentIdx === experimentIdx)
              .filter(row => !row.success)
              .map(_.counterExampleBin)
              .take(1)
          val eg = egs.flatten.headOption
          eg match
            case None => None
            case Some(bytes) =>
              os.write(egPath, bytes.array)
              // val toolClasspath = build.omnilink.tool
              //   .runClasspath()
              //   .map(_.path.toString())
              //   .mkString(":")
              // val toolProc = os.proc(
              //   mill.util.Jvm.javaExe,
              //   build.omnilink.tool.forkArgs(),
              //   "-cp",
              //   toolClasspath,
              //   "omnilink.Tool",
              //   "triage",
              //   unpackValidationEnv().path / specToValidateMC().path.last,
              //   egPath,
              // )
              // val result = toolProc.call()
              // val tags = result.out.lines()
              Some((traceId, PathRef(egPath), List[String]()))
      end counterExample

      def unpackTrace = Task.Input[PathRef]:
        inDBTransaction: db =>
          db
            .stream:
              EvalDB.Trace.select
                .filter(_.configId === configId)
                .filter(_.experimentIdx === experimentIdx)
                .sortBy(_.id)
                .map(_.trace)
            .map(_.array)
            .zipWithIndex
            .foreach: (arr, idx) =>
              os.write(Task.dest / s"tracing-$idx.log", arr)
        PathRef(Task.dest)
      end unpackTrace

      def unpackValidationEnv = Task[PathRef]:
        val tracesFolder = unpackTrace().path
        val spec = specToValidate().path
        val mcSpec = specToValidateMC().path
        val mcConfig = specToValidateMCConfig().path

        build.omnilink.tool
          .runner()
          .run(
            List[os.Shellable](
              "gen-tla",
              spec,
              tracesFolder,
              "--dest-dir",
              Task.dest,
            ),
          )

        os.copy(from = mcSpec, to = Task.dest / mcSpec.last)
        os.copy(from = mcConfig, to = Task.dest / mcConfig.last)
        PathRef(Task.dest)
      end unpackValidationEnv

      def discardTrace() = Task.Command(exclusive = true)[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Validation
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
          db.run:
            EvalDB.Trace
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
          db.run:
            EvalDB.GatherLog
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
        // Extra transaction, because ??? need it to pass foreign key check
        inDBTransaction: db =>
          db.run:
            EvalDB.Experiment
              .delete: row =>
                row.configId === configId
                  && row.idx === experimentIdx
        ()
      end discardTrace

      def discardValidation() = Task.Command[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Validation
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx

          ()
      end discardValidation

      def discardNegativeValidation() = Task.Command[Unit]:
        inDBTransaction: db =>
          db.run:
            EvalDB.Validation
              .delete: row =>
                row.configId === configId
                  && row.experimentIdx === experimentIdx
                  && !row.success

          ()
      end discardNegativeValidation

      // enable concurrency for now. TODO: would this interfere with itself? I don't think so...
      def gatherTrace() = Task.Command(exclusive = false)[Unit]:
        val exe = tracingExecutable()

        if inDBTransaction: db =>
            db.run:
              EvalDB.Experiment.select
                .filter(_.configId === configId)
                .filter(_.idx === experimentIdx)
                .size > 0
        then println(s"already gathered trace $traceId")
        else
          println(s"gathering trace $traceId")

          val rrTracesDir = Task.dest / "rr"
          os.makeDir.all(rrTracesDir)

          val startTime = LocalDateTime.now()
          val result = os
            .proc(
              build.omnilink.nativebuilds.rr.bin.out(),
              "record",
              "--chaos",
              "--",
              exe,
            )
            .call(
              cwd = Task.dest,
              mergeErrIntoOut = true,
              check = false,
              env = Map(
                "_RR_TRACE_DIR" -> rrTracesDir.toString(),
                "OMNILINK_OPERATIONS" -> operationCount.toString(),
                "OMNILINK_THREADS" -> threadCount.toString(),
              ),
            )
          val endTime = LocalDateTime.now()
          result.out.lines().foreach(println)

          // Note: we don't really lose much from disabling this; we can also capture
          //       a full impl replay of any crashes. We record the code below.
          // if result.exitCode != 0
          // then
          //   println(
          //     s"saw exit code ${result.exitCode}; check in ${Task.dest}",
          //   )
          //   throw RuntimeException("trace collection failed")

          val rrLatestTrace = rrTracesDir / "latest-trace"
          os.call(
            List[os.Shellable](
              build.omnilink.nativebuilds.rr.bin.out(),
              "pack",
              rrLatestTrace,
            ),
            stdout = os.Inherit,
            stderr = os.Inherit,
          )
          val rrZipFile = Task.dest / "rr.zip"
          os.zip(rrZipFile, Seq(rrLatestTrace))

          inDBTransaction: db =>
            db.run:
              EvalDB.Experiment.insert
                .columns(
                  _.configId := configId,
                  _.idx := experimentIdx,
                  _.specPath := specToValidate().path,
                  _.mcSpecPath := specToValidateMC().path,
                  _.mcConfigPath := specToValidateMCConfig().path,
                  _.startTime := startTime,
                  _.endTime := endTime,
                  _.exitCode := result.exitCode,
                  _.rrZip := geny.Bytes(os.read.bytes(rrZipFile)),
                )

            db.run:
              EvalDB.GatherLog.insert
                .columns(
                  _.configId := configId,
                  _.experimentIdx := experimentIdx,
                  _.name := "stdout",
                  _.text := result.out.text(),
                )
            os.list(Task.dest)
              .sortBy(_.last)
              .filter(_.last.endsWith(".log"))
              .zipWithIndex
              .foreach: (file, id) =>
                db.run:
                  EvalDB.Trace.insert
                    .columns(
                      _.configId := configId,
                      _.experimentIdx := experimentIdx,
                      _.id := id,
                      _.trace := geny.Bytes(os.read.bytes(file)),
                    )
          ()
      end gatherTrace

      def concurrencyLimit = Task.Input:
        Task.ctx().env.get("TLC_CONCURRENCY").fold(1)(_.toInt)

      def validateTrace() = Task.Command[Unit]:
        if inDBTransaction: db =>
            db.run:
              EvalDB.Validation.select
                .filter(_.configId === configId)
                .filter(_.experimentIdx === experimentIdx)
                .size > 0
        then println(s"already validated trace $traceId")
        else
          Using.resource(ValidateConcurrencyLimiter(concurrencyLimit())): _ =>
            val validationDir = unpackValidationEnv().path
            os.copy.over(
              validationDir,
              Task.dest,
              replaceExisting = true,
              createFolders = true,
            )
            val startTime = LocalDateTime.now()
            val tlcClasspath =
              build.tlc
                .runClasspath()
                .map(_.path.toString())
                .mkString(":")
            val tlcProc = os.proc(
              mill.util.Jvm.javaExe,
              "-XX:+UseParallelGC",
              "-cp",
              tlcClasspath,
              "tlc2.TLC",
              "-gzip",
              "-noGenerateSpecTE",
              "-dump",
              "class,pgo.util.CaptureCounterExamples",
              Task.dest / specToValidateMC().path.last,
            )

            val tlcOutFile = Task.dest / "tlc_output.txt"
            var isError = false
            val tlcResult = tlcProc.call(
              cwd = Task.dest,
              check = false,
              stdout = os.ProcessOutput.Readlines: line =>
                def out(line: String): Unit =
                  os.write
                    .append(target = tlcOutFile, data = List(line, "\n"))
                  println(line)
                if line.startsWith(
                    "Error: The behavior up to this point is:",
                  )
                then
                  isError = true
                  out(line) // show the error line
                  out("(omitting counterexample...)")
                if line.endsWith(" states left on queue.")
                then isError = false
                if !isError
                then out(line)
              ,
              mergeErrIntoOut = true,
            )

            val endTime = LocalDateTime.now()
            val counterExampleFile =
              Task.dest / "CaptureCounterExamples.bin"

            val counterExampleBinOpt =
              if tlcResult.exitCode != 0
              then
                if os.exists(counterExampleFile)
                then Some(os.read.bytes(counterExampleFile))
                else Some(upack.writeToByteArray(upack.Arr()))
              else None

            println(
              s"trace $traceId validation --> TLC code ${tlcResult.exitCode}, ${Duration.between(startTime, endTime).toMinutes()}min",
            )

            inDBTransaction: db =>
              db.run:
                EvalDB.Validation.insert
                  .columns(
                    _.configId := configId,
                    _.experimentIdx := experimentIdx,
                    _.counterExampleBin := counterExampleBinOpt
                      .map(geny.Bytes(_)),
                    _.logTxt := os.read(tlcOutFile),
                    _.success := tlcResult.exitCode == 0,
                    _.startTime := startTime,
                    _.endTime := endTime,
                  )
            ()
      end validateTrace

      def tsVizRaw() = Task.Command[Unit]:
        val logsDir = unpackTrace().path
        build.omnilink.tool
          .runner()
          .run(
            List[os.Shellable](
              "showlog",
              "tsviz",
              logsDir,
              BuildCtx.workspaceRoot / s"$traceId.tsviz",
            ),
          )
      end tsVizRaw

      def rrZipFile: T[PathRef] = Task.Input:
        inDBTransaction: db =>
          val bytes = db.run:
            EvalDB.Experiment.select
              .filter(_.configId === configId)
              .filter(_.idx === experimentIdx)
              .map(_.rrZip)
              .single

          val dest = Task.dest / "rr.zip"
          os.write(dest, bytes.array)
          PathRef(dest)
      end rrZipFile

      def rrTraceDir: T[PathRef] = Task:
        os.unzip(rrZipFile().path, Task.dest)
        PathRef(Task.dest)
      end rrTraceDir

      def rrReplay() = Task.Command(exclusive = true)[Unit]:
        tracingExecutable()
        if !mill.constants.Util.hasConsole()
        then
          Task.fail("rrReplay needs to be run with the -i/--interactive flag")
        os.call(
          List[os.Shellable](
            build.omnilink.nativebuilds.rr.bin.out(),
            "replay",
            rrTraceDir(),
          ),
          stdout = os.Inherit,
          stderr = os.Inherit,
          stdin = os.Inherit,
        )
      end rrReplay

      def rrReplayServer() = Task.Command(exclusive = true)[Unit]:
        tracingExecutable()
        os.call(
          List[os.Shellable](
            build.omnilink.nativebuilds.rr.bin.out(),
            "replay",
            "-s",
            "50505",
            "-k",
            rrTraceDir(),
          ),
          stdout = os.Inherit,
          stderr = os.Inherit,
        )
      end rrReplayServer
    end TraceModule
  end ConfigModule
end TracingConfigModule
